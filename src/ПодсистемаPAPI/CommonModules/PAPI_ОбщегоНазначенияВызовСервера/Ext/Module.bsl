#Область License

//MIT License

//Copyright (c) 2024 Dmitrii Sidorenko

//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:

//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.

//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.

#КонецОбласти

#Область ПрограммныйИнтерфейс

#Область СериализацияДесериализацияДанных 

// Возвращает чаще всего используемые ПараметрыЗаписиJSON (JSONWriterSettings)
// 
// Возвращаемое значение:
//  Результат - Структура - Стандартное заполнение
//
Функция СтандартныеПараметрыJSON() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ПереносСтрок",					ПереносСтрокJSON.Нет);
	Результат.Вставить("СимволОтступа",					" ");
	Результат.Вставить("ИспользоватьДвойныеКавычки",	Истина);
	Результат.Вставить("ЭкранированиеСимволов",			ЭкранированиеСимволовJSON.Нет);
	Результат.Вставить("ЭкранироватьАмперсанд",			Ложь);
	Результат.Вставить("ЭкранироватьОдинарныеКавычки",	Ложь);
	Результат.Вставить("ЭкранироватьРазделителиСтрок",	Ложь);
	Результат.Вставить("ЭкранироватьУгловыеСкобки",		Ложь);
	Результат.Вставить("ЭкранироватьСлеш",				Ложь);	
	
	Возврат Результат;		
	
КонецФункции

// Преобразует данные в формат JSON
//
// Параметры:
//  ВходящиеПараметры	 - Структура - Параметры формирование JSON
//  ВходныеДанные		 - ЛюбоеЗначение - Данные которые нужно перевести в JSON
// 
// Возвращаемое значение:
//  Результат - Структура
//  	Отработал - Булево - Выполнено или нет
//  	ТекстОшибки - Строка - Текст ошибки если функция отработала с ошибкой
//  	Результат - Строка - JSON
//
Функция ЗаписатьДанныеВJSON(Знач ВходящиеПараметры = Неопределено, Знач ВходныеДанные = "") Экспорт
	
	Результат = Новый Структура("Отработал, ТекстОшибки", Истина, "");
	
	Если ВходящиеПараметры = Неопределено Тогда 
		ВходящиеПараметры = СтандартныеПараметрыJSON(); 	
	КонецЕсли;	
	
	ПараметрыJSON	= Новый ПараметрыЗаписиJSON(ВходящиеПараметры.ПереносСтрок,
												ВходящиеПараметры.СимволОтступа,
												ВходящиеПараметры.ИспользоватьДвойныеКавычки,
												ВходящиеПараметры.ЭкранированиеСимволов,
												ВходящиеПараметры.ЭкранироватьУгловыеСкобки,
												ВходящиеПараметры.ЭкранироватьРазделителиСтрок,
												ВходящиеПараметры.ЭкранироватьАмперсанд,
												ВходящиеПараметры.ЭкранироватьОдинарныеКавычки,
												ВходящиеПараметры.ЭкранироватьСлеш);
	
	
	Попытка
		ЗаписьJSON						= Новый ЗаписьJSON;
		ЗаписьJSON.ПроверятьСтруктуру 	= Истина;
		ЗаписьJSON.УстановитьСтроку(ПараметрыJSON);	
		ЗаписатьJSON(ЗаписьJSON, ВходныеДанные);
		Результат.Вставить("Результат",	ЗаписьJSON.Закрыть());
	Исключение
		Результат.Отработал 			= Ложь;
		Результат.ТекстОшибки 			= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции	

// Десериализует строку JSON в формат данных 1С
//
// Параметры:
//  СтрокаJSON - Строка - JSON
// 
// Возвращаемое значение:
//  Результат - Структура
//  	Отработал - Булево - Выполнено или нет
//  	ТекстОшибки - Строка - Текст ошибки если функция отработала с ошибкой
//  	Результат - ЛюбоеЗначение - Данные в формате 1С
//
Функция ЧтениеДанныхИзJSON(Знач СтрокаJSON) Экспорт
	
	Результат = Новый Структура("Отработал, ТекстОшибки", Истина, "");
						
	Попытка
		ЧтениеJSON 				= Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
		Результат.Вставить("Результат", ПрочитатьJSON(ЧтениеJSON));
	Исключение
		Результат.Отработал 	= Ложь;
		Результат.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Десериализует поток JSON в формат данных 1С
//
// Параметры:
//  ПотокJSON	 - Поток -
// 
// Возвращаемое значение:
//  Результат - Структура
// 		Отработал - Булево - Выполнено или нет
//  	ТекстОшибки - Строка - Текст ошибки если функция отработала с ошибкой
//  	Результат - ЛюбоеЗначение - Данные в формате 1С
//
Функция ЧтениеПотокаИзJSON(Знач ПотокJSON) Экспорт
	
	Результат = Новый Структура("Отработал, ТекстОшибки", Истина, "");
					
	Попытка
		ЧтениеJSON 				= Новый ЧтениеJSON;
		ЧтениеJSON.ОткрытьПоток(ПотокJSON);
		Результат.Вставить("Результат", ПрочитатьJSON(ЧтениеJSON));
	Исключение
		Результат.Отработал 	= Ложь;
		Результат.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Преобразует данные в формат XML
//
// Параметры:
//  ВходныеДанные - Строка - Данные которые нужно перевести в XML
// 
// Возвращаемое значение:
//  Результат - Структура
//  Отработал - Булево - Выполнено или нет
//  ТекстОшибки - Строка - Текст ошибки если функция отработала с ошибкой
//  Результат - Строка - XML
//
Функция СериализаторXML(Знач ВходныеДанные) Экспорт
	
	Результат = Новый Структура("Отработал, ТекстОшибки", Истина, "");
			
	Попытка
		ЗаписьXML 				= Новый ЗаписьXML();
		ЗаписьXML.УстановитьСтроку();
		СериализаторXDTO.ЗаписатьXML(ЗаписьXML, ВходныеДанные);
		Результат.Вставить("Результат",ЗаписьXML.Закрыть());
	Исключение
		Результат.Отработал 	= Ложь;
		Результат.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

// Десериализует строку XML в формат данных 1С
//
// Параметры:
//  ВходныеДанные - Строка - XML
// 
// Возвращаемое значение:
//  Результат - Структура
//  Отработал - Булево - Выполнено или нет
//  ТекстОшибки - Строка - Текст ошибки если функция отработала с ошибкой
//  Результат - ЛюбоеЗначение - Данные в формате 1С
//
Функция ДесериализаторXML(Знач ВходныеДанные) Экспорт
	
	Результат = Новый Структура("Отработал, ТекстОшибки", Истина, "");
	
	Попытка
		ЧтениеXML 				= Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(ВходныеДанные);
		ДанныеВозврат 			= СериализаторXDTO.ПрочитатьXML(ЧтениеXML);
		ЧтениеXML.Закрыть(); 
		Результат.Вставить("Результат", ДанныеВозврат);
	Исключение
		Результат.Отработал 	= Ложь;
		Результат.ТекстОшибки 	= ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции


// Удалить несериализуемые типы
//
// Параметры:
//  СтруктураДляСериализации - Структура - Данные до сериализации
//  Переформатировать - Булево - Удалить из структуры или перевести в строку
//
Процедура УдалитьНесериализуемыеТипы(Знач СтруктураДляСериализации, Знач Переформатировать = Ложь) Экспорт  
	
	КлючиУдаления = Новый Массив; 
		
	СоответствиеПереформатированных = Новый Соответствие;	
	Для Каждого элСтруктуры Из СтруктураДляСериализации Цикл 	
		Если ТипЗнч(элСтруктуры.Значение) = Тип("ХранилищеЗначения") Тогда  		
			КлючиУдаления.Добавить(элСтруктуры.Ключ);	
		КонецЕсли;  
		
		Если ТипЗнч(элСтруктуры.Значение) = Тип("УникальныйИдентификатор") Тогда 
			Если Не Переформатировать Тогда 
				КлючиУдаления.Добавить(элСтруктуры.Ключ);
			Иначе  
				СоответствиеПереформатированных.Вставить(элСтруктуры.Ключ, Строка(элСтруктуры.Значение));
			КонецЕсли;	
		КонецЕсли; 
	КонецЦикла;	
	
	Для Каждого ключУдаления Из КлючиУдаления Цикл 
		СтруктураДляСериализации.Удалить(ключУдаления);	
	КонецЦикла; 
	
	Если Переформатировать Тогда 
		Для Каждого элСоответствия Из СоответствиеПереформатированных Цикл 
			СтруктураДляСериализации.Вставить(элСоответствия.Ключ, элСоответствия.Значение);
		КонецЦикла;	
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти


#Область РаботаССсылками
// Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки
//
// Параметры:
//  Ссылка 		- ЛюбаяСсылка - Значение любой ссылки информационной базы данных
//  ИмяТаблицы	- Строка  - представление типа ссылки
// 
// Возвращаемое значение:
//  Результат - Булево - (Истина - ссылка существует, Ложь - ссылка не существует)
//
Функция СсылкаСуществует(Знач Ссылка, Знач ИмяТаблицы = Неопределено) Экспорт
		
    ТекстЗапроса = "
        |ВЫБРАТЬ
        |    Ссылка
        |ИЗ
        |    [ИмяТаблицы]
        |ГДЕ
        |    Ссылка = &Ссылка
        |";
    Если ИмяТаблицы = Неопределено Тогда 
    	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицыПоСсылке(Ссылка));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "[ИмяТаблицы]", ИмяТаблицы);
	КонецЕсли;	
	
    Запрос		 = Новый Запрос;
    Запрос.Текст = ТекстЗапроса;
    Запрос.УстановитьПараметр("Ссылка", Ссылка);
    
    Возврат НЕ Запрос.Выполнить().Пустой();
    
КонецФункции

// Возвращает полное имя объекта метаданных по переданному значению ссылки
//  Например:
//  "Справочник.Номенклатура";
//  "Документ.ПриходнаяНакладная"
//
// Параметры:
//  Ссылка	 - ЛюбаяСсылка	 - значение ссылки, для которого необходимо получить имя таблицы ИБ
// 
// Возвращаемое значение:
//  Строка - Полное имя объекта метаданных для указанного значения ссылки
//
Функция ИмяТаблицыПоСсылке(Знач Ссылка) Экспорт
    
    Возврат Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).ПолноеИмя();
    
КонецФункции

// Восстанавливает ГУИД битой ссылки
//
// Параметры:
//  ГУИДУдОбъекта - Строка - Представление битой ссылки
//
// Пример:
//	"<Объект не найден> (84:bf5600145e3710ab11dda4c605dbe824)"
//
// Возвращаемое значение:
// 	ГУИД - Строка - 05dbe824-a4c6-11dd-bf56-00145e3710ab
//
Функция ПолучитьГУИДБитойСсылки(Знач ГУИДУдОбъекта) Экспорт 
	
	ГУИДУдОбъектаСтр = СтрЗаменить(ГУИДУдОбъекта,"<Объект не найден> (","");
	ГУИДУдОбъектаСтр = СтрЗаменить(ГУИДУдОбъектаСтр,")","");
	ГУИДУдОбъектаСтр = СтрЗаменить(ГУИДУдОбъектаСтр,"0x","");
	ГУИДУдОбъектаСтр = Сред(ГУИДУдОбъектаСтр, Найти(ГУИДУдОбъектаСтр,":")+1, СтрДлина(ГУИДУдОбъектаСтр));
	
	// Преобразуем GUID
	ГУИД = Сред(ГУИДУдОбъектаСтр,25,8)
			+ "-"
			+ Сред(ГУИДУдОбъектаСтр,21,4)
			+ "-" 
			+ Сред(ГУИДУдОбъектаСтр,17,4)
			+ "-"
			+ Сред(ГУИДУдОбъектаСтр,1,4)
			+ "-"
			+ Сред(ГУИДУдОбъектаСтр,5,12);			
	    
	Возврат ГУИД;
	
КонецФункции

// Проверка того, что переданный тип является ссылочным типом данных.
//
// Параметры:
//  Тип	 - ЛюбаяСсылка	 - Проверяем значение на ссылочный тип
// 
// Возвращаемое значение:
//  Булево - 
//
Функция ЭтоСсылка(Знач Тип) Экспорт
	
	Возврат Тип <> Тип("Неопределено") 
		И (Справочники.ТипВсеСсылки().СодержитТип(Тип)
		Или Документы.ТипВсеСсылки().СодержитТип(Тип)
		Или Перечисления.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип)
		Или БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип)
		Или БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		Или Задачи.ТипВсеСсылки().СодержитТип(Тип)
		Или ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип));
	
КонецФункции

// Получить навигационную ссылку (Вариант синтаксиса: Ссылка на объект)
//
// Параметры:
//  Ссылка 			- ЛюбаяСсылка - Значение любой ссылки информационной базы данных
//	ИмяРеквизита 	- Строка - Если требуется получить навигационную ссылку на реквизит объекта, 
//								то в данном параметре следует указать имя реквизита
//	Индекс 	- Число - Индекс строки в табличной части, если требуется получить навигационную ссылку на реквизит табличной части.
// 
// Возвращаемое значение:
//  Строка - Навигационная Ссылка
//
Функция ПолучитьНавигационнуюСсылкуОбъекта(Знач Ссылка, Знач ИмяРеквизита = "", Знач Индекс = -1) Экспорт
	
	Результат = "";

	Если Не ПустаяСтрока(ИмяРеквизита) Тогда 
		
		Если Индекс >= 0 Тогда
			
			Результат = ПолучитьНавигационнуюСсылку(Ссылка, ИмяРеквизита, Индекс);
			
		Иначе
			
			Результат = ПолучитьНавигационнуюСсылку(Ссылка, ИмяРеквизита);
			
		КонецЕсли;		
		
	Иначе
		
		Результат = ПолучитьНавигационнуюСсылку(Ссылка);
		
	КонецЕсли;	
			
	Возврат Результат;
	
КонецФункции	

// Получить ссылку из навигационной
//
// Параметры:
//  НавигационнаяСсылка	 - Строка - Пример: "e1cib/data/Справочник.Валюты?ref=9e0108002700700111e1cc2f22dd80d2"
// 
// Возвращаемое значение:
//   ЛюбаяСсылка - Найденная ссылка 
//
Функция ПолучитьСсылкуИзНавигационной(Знач НавигационнаяСсылка) Экспорт
		
    ПерваяТочка = Найти(НавигационнаяСсылка, "e1cib/data/");
    ВтораяТочка = Найти(НавигационнаяСсылка, "?ref=");
    
    ПредставлениеТипа   = Сред(НавигационнаяСсылка, ПерваяТочка + 11, ВтораяТочка - ПерваяТочка - 11);
    ШаблонЗначения = ЗначениеВСтрокуВнутр(ПредопределенноеЗначение(ПредставлениеТипа + ".ПустаяСсылка"));
    ЗначениеСсылки = СтрЗаменить(ШаблонЗначения, "00000000000000000000000000000000", Сред(НавигационнаяСсылка, ВтораяТочка + 5));
    Результат = ЗначениеИзСтрокиВнутр(ЗначениеСсылки);
	
	Возврат Результат;
	
КонецФункции

// Найти объект и получить навигационную ссылку
//
// Параметры:
//  ТипОбъекта	 - Строка - Тип объекта
//  ИдОбъекта	 - Строка - Уникальный идентификатор
// 
// Возвращаемое значение:
//  Строка - Навигационная ссылка
//
Функция НайтиОбъектИПолучитьНавигационнуюСсылку(Знач ТипОбъекта, Знач ИдОбъекта) Экспорт 
	
	Результат = "";
	Попытка
		НайденнаяСсылка = XMLЗначение(Тип(ТипОбъекта), ИдОбъекта);
		перСсылкаСуществует = СсылкаСуществует(НайденнаяСсылка);
		
		Если перСсылкаСуществует Тогда 
			Результат = ПолучитьНавигационнуюСсылкуОбъекта(НайденнаяСсылка);	
		КонецЕсли;	
	Исключение	
		
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()); 
		PAPI_Логирование.ЗаписатьВЛог("PAPI.Ошибка", Перечисления.PAPI_ТипЛога.Ошибка, ТекстОшибки, "PAPI_ОбщегоНазначенияВызовСервера.НайтиОбъектИПолучитьНавигационнуюСсылку");
		
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции	

// Получить структуру из навигационной ссылки
//
// Параметры:
//  НавигационнаяСсылка	 - Строка - Навигационная ссылка
//	ПередТочкой - Строка - Если заполнено тогда в типе перед точкой будет вставлено переданное значение.
//		Пример: "Ссылка" , ТипОбъекта = "ДокументСсылка.ЗаказКлиента"
//
// Возвращаемое значение:
//  Структура - Структура ответа:
//		Отработал - Булево - Признак того, что результат получен или не получен
//		Результат - Структура - Содержит ИдОбъекта и ТипОбъекта
//
Функция СтруктураНавигационнойСсылки(Знач НавигационнаяСсылка, Знач  ПередТочкой = "") Экспорт
	
	Результат = Новый Структура("Отработал", Истина);
	
	Если СтрНайти(НавигационнаяСсылка,"e1cib/data/") = 0
		ИЛИ СтрНайти(НавигационнаяСсылка,"?ref=") = 0 Тогда 
		
		Результат.Отработал = Ложь; 
		Возврат Результат;
		
	КонецЕсли;
    	
	ПодготовленнаяСтрока = СтрЗаменить(НавигационнаяСсылка, "e1cib/data/", ""); 
	ПодготовленнаяСтрока = СтрЗаменить(ПодготовленнаяСтрока, "?ref=", "||");
	
	МассивРазделеннойСсылки = СтрРазделить(ПодготовленнаяСтрока, "||", Ложь);
	
	Если МассивРазделеннойСсылки.Количество() > 1 Тогда 
		ТипОбъекта = МассивРазделеннойСсылки[0];
		
		Если ЗначениеЗаполнено(ПередТочкой) Тогда 
			ТипОбъекта = СтрЗаменить(ТипОбъекта, ".", ПередТочкой + ".");	
		КонецЕсли;	
		
		ГУИДУдОбъектаСтр = Лев(МассивРазделеннойСсылки[1], 32);  
		
		ИдОбъекта = Сред(ГУИДУдОбъектаСтр,25,8) 
					+ "-" 
					+ Сред(ГУИДУдОбъектаСтр,21,4) 
					+ "-" 
					+ Сред(ГУИДУдОбъектаСтр,17,4) 
					+ "-" 
					+ Сред(ГУИДУдОбъектаСтр,1,4) 
					+ "-" 
					+ Сред(ГУИДУдОбъектаСтр,5,12);
		
		Результат.Вставить("Результат", Новый Структура("ИдОбъекта, ТипОбъекта", ИдОбъекта, ТипОбъекта));
		
		Возврат Результат;
		
	Иначе  
		
		Результат.Отработал = Ложь; 
		Возврат Результат;	
		
	КонецЕсли;
		
КонецФункции   

#КонецОбласти


#Область РаботаС_Hash
// Возвращает Хеш сумму строки
//
// Параметры:
//  ВходящиеДанные	 - Строка - строка
//  ТипХешФункции	 - Строка - Хеш функция (CRC32,MD5,SHA1,SHA256,SHA512)
//  УдалитьПробелы	 - Булево 
// 
// Возвращаемое значение:
//  Результат - ХешСумма
//
Функция ПолучитьХешСтроки(Знач ВходящиеДанные, Знач ТипХешФункции = "CRC32", Знач УдалитьПробелы = Ложь) Экспорт
	
	Хеш = Новый ХешированиеДанных(ХешФункция[ТипХешФункции]);
	Хеш.Добавить(ВходящиеДанные);
	Результат = "";
	Если УдалитьПробелы Тогда
		Если ВРег(ТипХешФункции) = ВРег("CRC32") Тогда 
			Результат = СтрЗаменить(Хеш.ХешСумма,Символы.НПП,"")	
		Иначе
			Результат = СтрЗаменить(Хеш.ХешСумма," ","")	
		КонецЕсли;	
	Иначе
		Результат = Хеш.ХешСумма;	
	КонецЕсли;   
	
	Возврат Результат;  
	
КонецФункции

// Возвращает Хеш сумму файла
//
// Параметры:
//  ВходящийФайл	 - Строка - файл
//  ТипХешФункции	 - Строка - Хеш функция (CRC32,MD5,SHA1,SHA256,SHA512)
//  УдалитьПробелы	 - Булево
// 
// Возвращаемое значение:
//  Результат - ХешСумма
//
Функция ПолучитьХешФайла(Знач ВходящийФайл, Знач ТипХешФункции = "CRC32", Знач УдалитьПробелы = Ложь) Экспорт
	
	Хеш = Новый ХешированиеДанных(ХешФункция[ТипХешФункции]);
	Хеш.ДобавитьФайл(ВходящийФайл);
	Результат = "";
	Если УдалитьПробелы Тогда
		Если ВРег(ТипХешФункции) = ВРег("CRC32") Тогда 
			Результат = СтрЗаменить(Хеш.ХешСумма,Символы.НПП,"");	
		Иначе
			Результат = СтрЗаменить(Хеш.ХешСумма," ","");	
		КонецЕсли;	
	Иначе
		Результат = Хеш.ХешСумма;	
	КонецЕсли;   
	
	Возврат Результат;
	
КонецФункции

// Преобразует Свойство "ВерсияДанных" в число
//
// Параметры:
//  ВерсияСтрокой			 - Строка - "ВерсияДанных"
//  ВыбранныйПорядокБайтов	 - Строка - Порядок байтов Формат представления целых чисел в память компьютера (LittleEndian или BigEndian)
// 
// Возвращаемое значение:
//  Результат - Число
//
Функция ПрочитатьВерсию(Знач ВерсияСтрокой, Знач ВыбранныйПорядокБайтов = "BigEndian") Экспорт 
	
	СтрокаHEX 		= Base64Значение(ВерсияСтрокой);
	перЧтениеДанных = Новый ЧтениеДанных(СтрокаHEX);
	// LittleEndian или BigEndian
	Число64 		= перЧтениеДанных.ПрочитатьЦелое64(ПорядокБайтов[ВыбранныйПорядокБайтов]);
	Результат 		= 0;
	Если Число64 <> Неопределено Тогда
		Результат 	= Число64;
	КонецЕсли;	
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти


#Область РаботаСПодсистемами  

// Проверяем есть ли у подсистемы PAPI подчиненная подсистема
//
// Параметры:
//  ИмяПодсистемы - Строка - Название подсистемы. Например: "PAPI_ПодпискиНаСобытия"
// 
// Возвращаемое значение:
//  Результат - Булево
//
Функция ПодчиненнаяПодсистемаPAPIСуществует(Знач ИмяПодсистемы) Экспорт         
	
	Результат = Ложь; 
	
	Если Метаданные.Подсистемы.Найти("PAPI") <> Неопределено Тогда 
		Если Метаданные.Подсистемы.PAPI.Подсистемы.Найти(ИмяПодсистемы) <> Неопределено Тогда
			Результат = Истина;
		КонецЕсли;	
	КонецЕсли;
	
	Возврат Результат; 
	
КонецФункции	

#КонецОбласти


#Область РаботаСКонстантами

// Поменять значение константы
//
// Параметры:
//  ИмяКонстанты	 - Строка - Наименование константы 
//  НовоеЗначение	 - ЛюбоеЗначение - Новое значение константы которое нужно записать 
//
Процедура ПоменятьЗначениеКонстанты(Знач ИмяКонстанты, Знач НовоеЗначение) Экспорт
	
	Результат = Константы[ИмяКонстанты].СоздатьМенеджерЗначения();
	
	// Читаем значение
	Результат.Прочитать();    
				    
	Если Результат.Значение <> НовоеЗначение Тогда 
					 
		// Меняем значение
		Результат.Значение = НовоеЗначение;
					 
		// Записываем значение
		Результат.Записать();
		
	КонецЕсли;
	
КонецПроцедуры	

// Прочитать значение константы
//
// Параметры:
//  ИмяКонстанты - Строка - Наименование константы 
// 
// Возвращаемое значение:
//  ЛюбоеЗначение - Текущее значение Константы
//
Функция ПрочитатьЗначениеКонстанты(Знач ИмяКонстанты) Экспорт
		
	Возврат Константы[ИмяКонстанты].Получить()
	
КонецФункции


// Заполнить параметр сеанса значением константы
//
// Параметры:
//  ИмяКонстанты		 - Строка - Имя константы
//  ИмяПараметраСеанса	 - Строка - Имя параметра сеанса
//
Процедура ЗаполнитьПараметрСеансаЗначениемКонстанты(Знач ИмяКонстанты, Знач ИмяПараметраСеанса)  Экспорт 
	
	ПараметрыСеанса[ИмяПараметраСеанса] = ПрочитатьЗначениеКонстанты(ИмяКонстанты);
		
КонецПроцедуры	

#КонецОбласти


#Область РаботаСРегистрамиСведений

// Добавляет одну запись в регистр сведений по переданным значениям структуры.
//
// Параметры:
//  СтруктураЗаписи - Структура - структура, по значениям которой необходимо создать набор записей и заполнить этот набор.
//  ИмяРегистра     - Строка - имя регистра сведений, в который необходимо добавить запись.
// 
Процедура ДобавитьЗаписьВРегистрСведений(СтруктураЗаписи, Знач ИмяРегистра, Загрузка = Ложь) Экспорт

	НаборЗаписей = СоздатьНаборЗаписейРегистраСведений(СтруктураЗаписи, ИмяРегистра);
	
	// Добавляем только одну запись в новый набор записей.
	НоваяЗапись = НаборЗаписей.Добавить();
	
	// Заполняем значения свойств записи из переданной структуры.
	ЗаполнитьЗначенияСвойств(НоваяЗапись, СтруктураЗаписи);

	НаборЗаписей.ОбменДанными.Загрузка = Загрузка;
	
	// записываем набор записей
	НаборЗаписей.Записать();

КонецПроцедуры

// Обновляет запись в регистр сведений по переданным значениям структуры.
//
// Параметры:
//  СтруктураЗаписи - Структура - структура, по значениям которой необходимо создать менеджер записи и обновить запись.
//  ИмяРегистра     - Строка - имя регистра сведений, в котором необходимо обновить запись.
// 
Процедура ОбновитьЗаписьВРегистрСведений(СтруктураЗаписи, Знач ИмяРегистра) Экспорт

	МетаданныеРегистра = Метаданные.РегистрыСведений[ИмяРегистра]; 
	
	// Создаем менеджер записи регистра.
	МенеджерЗаписи = РегистрыСведений[ИмяРегистра].СоздатьМенеджерЗаписи();
	
	// Устанавливаем отбор по измерениям регистра.
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл

		ИмяИзмерения = Измерение.Имя;
		
		// Если задано значение в структуре, то отбор устанавливаем.
		Если СтруктураЗаписи.Свойство(ИмяИзмерения) Тогда

			МенеджерЗаписи[ИмяИзмерения] = СтруктураЗаписи[ИмяИзмерения];

		КонецЕсли;

	КонецЦикла;
	
	// Считываем запись из базы данных.
	МенеджерЗаписи.Прочитать();
	
	// Заполняем значения свойств записи из переданной структуры.
	ЗаполнитьЗначенияСвойств(МенеджерЗаписи, СтруктураЗаписи);
	
	// записываем менеджер записи
	МенеджерЗаписи.Записать();

КонецПроцедуры

// Удаляет набор записей в регистре по переданным значениям структуры.
//
// Параметры:
//  СтруктураЗаписи - Структура - структура, по значениям которой необходимо удалить набор записей.
//  ИмяРегистра     - Строка - имя регистра сведений, в котором необходимо удалить набор записей.
// 
Процедура УдалитьНаборЗаписейВРегистреСведений(СтруктураЗаписи, ИмяРегистра, Загрузка = Ложь) Экспорт

	НаборЗаписей = СоздатьНаборЗаписейРегистраСведений(СтруктураЗаписи, ИмяРегистра);

	НаборЗаписей.ОбменДанными.Загрузка = Загрузка;
	
	// записываем набор записей
	НаборЗаписей.Записать();

КонецПроцедуры

// Создает набор записей регистра сведений по переданным значениям структуры. Добавляет одну запись в набор.
//
// Параметры:
//  СтруктураЗаписи - Структура - структура по значениям которой необходимо создать набор записей и заполнить этот набор.
//  ИмяРегистра     - Строка - имя регистра сведений.
//  
// Возвращаемое значение:
//   РегистрСведенийНаборЗаписей - набор записей регистра по указанному отбору.
// 
Функция СоздатьНаборЗаписейРегистраСведений(СтруктураЗаписи, ИмяРегистра) Экспорт

	НаборЗаписей = РегистрыСведений[ИмяРегистра].СоздатьНаборЗаписей(); // РегистрСведенийНаборЗаписей
	
	// Устанавливаем отбор по измерениям регистра.
	Для Каждого КлючЗначение Из СтруктураЗаписи Цикл
		УстановитьЗначениеЭлементаОтбора(НаборЗаписей.Отбор, КлючЗначение.Ключ, КлючЗначение.Значение);
	КонецЦикла;

	Возврат НаборЗаписей;

КонецФункции

// Устанавливает элемент отбора
// Параметры:
//   Отбор - Отбор - произвольный отбор.
//   КлючЭлемента - Строка - имя элемента отбора.
//   ЗначениеЭлемента - Произвольный - значение элемента отбора.
// 
Процедура УстановитьЗначениеЭлементаОтбора(Отбор, КлючЭлемента, ЗначениеЭлемента) Экспорт

	ЭлементОтбора = Отбор.Найти(КлючЭлемента);
	Если ЭлементОтбора <> Неопределено Тогда
		ЭлементОтбора.Установить(ЗначениеЭлемента);
	КонецЕсли;

КонецПроцедуры

#КонецОбласти



#Область РаботаСМетаданными

// Убрать из массива отсутствующие реквизиты
//
// Параметры:
//  МассивРеквизитов	- Массив - Массив с названиями реквизитов 
//  МетаданныеОбъекта 	- ОбъектМетаданных - объект, в котором требуется проверить наличие реквизита.
// 
// Возвращаемое значение:
//  Массив - Массив с названиями реквизитов существующих в объекте
//
Функция УбратьИзМассиваОтсутствующиеРеквизиты(Знач МассивРеквизитов, Знач МетаданныеОбъекта) Экспорт
	
	Результат = Новый Массив;
	
	Если ЗначениеЗаполнено(МассивРеквизитов) 
		И ТипЗнч(МассивРеквизитов) = Тип("Массив") Тогда 
		
		Для Каждого элМассива Из МассивРеквизитов Цикл
			
			Если Не ЗначениеЗаполнено(элМассива) Тогда 
				Продолжить;
			КонецЕсли;	
			
			Если ЕстьРеквизитОбъекта(элМассива, МетаданныеОбъекта) Тогда 
				
				Результат.Добавить(элМассива);
				
			КонецЕсли;	
					
		КонецЦикла;	
		
	КонецЕсли;	
	
	Возврат Результат;
	
КонецФункции	

// Позволяет определить, есть ли среди реквизитов объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - Строка - имя реквизита
//  МетаданныеОбъекта - ОбъектМетаданных - объект, в котором требуется проверить наличие реквизита.
//
// Возвращаемое значение:
//  Булево - Истина, если есть.
//
Функция ЕстьРеквизитОбъекта(Знач ИмяРеквизита, Знач МетаданныеОбъекта) Экспорт

	Реквизиты = МетаданныеОбъекта.Реквизиты; // КоллекцияОбъектовМетаданных
	Возврат Не (Реквизиты.Найти(ИмяРеквизита) = Неопределено);

КонецФункции


// Есть реквизит или свойство объекта
//
// Параметры:
//  Объект		 - ОбъектМетаданных - объект, в котором требуется проверить наличие реквизита.
//  ИмяРеквизита - Строка - имя реквизита 
// 
// Возвращаемое значение:
//  Булево - Истина, если есть. 
//
Функция ЕстьРеквизитИлиСвойствоОбъекта(Знач Объект, Знач ИмяРеквизита) Экспорт
	
	МассивУникальности = Новый Массив;
	СтруктураРеквизита = Новый Структура(ИмяРеквизита, МассивУникальности);
	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> МассивУникальности;
	
КонецФункции

#КонецОбласти

#КонецОбласти    


#Область РегламентныеЗадания

// Добавляет новое регламентное задание (без учета очереди заданий модели сервиса).
// 
// Параметры: 
//  Параметры - Структура - параметры добавляемого задания, возможные свойства:
//   * Использование - Булево - Истина, если регламентное задание должно выполняться автоматически согласно расписанию. 
//   * Метаданные    - ОбъектМетаданныхРегламентноеЗадание - обязательно для указания. Объект метаданных, на основе 
//                              которого будет создано регламентное задание.
//   * Параметры     - Массив - параметры регламентного задания. Количество и состав параметров должны соответствовать 
//                              параметрам метода регламентного задания.
//   * Ключ          - Строка - прикладной идентификатор регламентного задания.
//   * ИнтервалПовтораПриАварийномЗавершении - Число - интервал в секундах, через который нужно перезапускать задание 
//                              в случае его аварийного завершения.
//   * Расписание    - РасписаниеРегламентногоЗадания - расписание задания.
//   * КоличествоПовторовПриАварийномЗавершении - Число - количество повторов при аварийном завершении задания.
//
// Возвращаемое значение:
//  РегламентноеЗадание
//
Функция ДобавитьРегламентноеЗадание(Параметры) Экспорт

	МетаданныеЗадания = Параметры.Метаданные;
	Задание = РегламентныеЗадания.СоздатьРегламентноеЗадание(МетаданныеЗадания);
	
	Если Параметры.Свойство("Наименование") Тогда
		Задание.Наименование = Параметры.Наименование;
	Иначе
		Задание.Наименование = МетаданныеЗадания.Наименование;
	КонецЕсли;
	
	Если Параметры.Свойство("Использование") Тогда
		Задание.Использование = Параметры.Использование;
	Иначе
		Задание.Использование = МетаданныеЗадания.Использование;
	КонецЕсли;
	
	Если Параметры.Свойство("Ключ") Тогда
		Задание.Ключ = Параметры.Ключ;
	Иначе
		Задание.Ключ = МетаданныеЗадания.Ключ;
	КонецЕсли;
	
	Если Параметры.Свойство("ИмяПользователя") Тогда
		Задание.ИмяПользователя = Параметры.ИмяПользователя;
	КонецЕсли;
	
	Если Параметры.Свойство("ИнтервалПовтораПриАварийномЗавершении") Тогда
		Задание.ИнтервалПовтораПриАварийномЗавершении = Параметры.ИнтервалПовтораПриАварийномЗавершении;
	Иначе
		Задание.ИнтервалПовтораПриАварийномЗавершении = МетаданныеЗадания.ИнтервалПовтораПриАварийномЗавершении;
	КонецЕсли;
	
	Если Параметры.Свойство("КоличествоПовторовПриАварийномЗавершении") Тогда
		Задание.КоличествоПовторовПриАварийномЗавершении = Параметры.КоличествоПовторовПриАварийномЗавершении;
	Иначе
		Задание.КоличествоПовторовПриАварийномЗавершении = МетаданныеЗадания.КоличествоПовторовПриАварийномЗавершении;
	КонецЕсли;
	
	Если Параметры.Свойство("Параметры") Тогда
		Задание.Параметры = Параметры.Параметры;
	КонецЕсли;
	
	Если Параметры.Свойство("Расписание") Тогда
		Задание.Расписание = Параметры.Расписание;
	КонецЕсли;
	
	Задание.Записать();
	
	Возврат Задание;
	
КонецФункции


// Изменяет регламентное задание (без учета очереди заданий модели сервиса).
//
// Параметры: 
//  Идентификатор - ОбъектМетаданных - объект метаданных регламентного задания для поиска
//                                     непредопределенного регламентного задания.
//                - Строка - имя метаданных предопределенного регламентного задания
//                           или строка уникального идентификатора регламентного задания.
//                - УникальныйИдентификатор - идентификатор регламентного задания.
//                - РегламентноеЗадание - регламентное задание.
//
//  Параметры - Структура - параметры, которые следует установить заданию, возможные свойства:
//   * Использование - Булево - Истина, если регламентное задание должно выполняться автоматически согласно расписанию.
//   * Параметры     - Массив - параметры регламентного задания. Количество и состав параметров должны соответствовать
//                              параметрам метода регламентного задания.
//   * Ключ          - Строка - прикладной идентификатор регламентного задания.
//   * ИнтервалПовтораПриАварийномЗавершении - Число - интервал в секундах, через который нужно перезапускать задание
//                              в случае его аварийного завершения.
//   * Расписание    - РасписаниеРегламентногоЗадания - расписание задания.
//   * КоличествоПовторовПриАварийномЗавершении - Число - количество повторов при аварийном завершении задания.
//   
Процедура ИзменитьРегламентноеЗадание(Знач Идентификатор, Знач Параметры) Экспорт
	
	ВключенПривилегированныйРежим = Ложь;
	Если Не ПривилегированныйРежим() Тогда  
		ВключенПривилегированныйРежим = Истина;
		УстановитьПривилегированныйРежим(ВключенПривилегированныйРежим);
	КонецЕсли;
	
	ИдентификаторЗадания = УточненныйИдентификаторЗадания(Идентификатор);
	
	Если ИдентификаторЗадания = Неопределено Тогда
		ТекстИсключения = НСтр("ru = 'Регламентное задание по переданному идентификатору не найдено.'");	
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
	Попытка

		Задание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(ИдентификаторЗадания);
		Если Задание <> Неопределено Тогда
			ЕстьИзменения = Ложь;
			
			ОбновитьЗначениеСвойстваЗадания(Задание, "Наименование", Параметры, ЕстьИзменения);
			ОбновитьЗначениеСвойстваЗадания(Задание, "Использование", Параметры, ЕстьИзменения);
			ОбновитьЗначениеСвойстваЗадания(Задание, "Ключ", Параметры, ЕстьИзменения);
			ОбновитьЗначениеСвойстваЗадания(Задание, "ИмяПользователя", Параметры, ЕстьИзменения);
			ОбновитьЗначениеСвойстваЗадания(Задание, "ИнтервалПовтораПриАварийномЗавершении", Параметры, ЕстьИзменения);
			ОбновитьЗначениеСвойстваЗадания(Задание, "КоличествоПовторовПриАварийномЗавершении", Параметры, ЕстьИзменения);
			ОбновитьЗначениеСвойстваЗадания(Задание, "Параметры", Параметры, ЕстьИзменения);
			ОбновитьЗначениеСвойстваЗадания(Задание, "Расписание", Параметры, ЕстьИзменения);
			
			Если ЕстьИзменения Тогда
				Задание.Записать();
			КонецЕсли;
		КонецЕсли;
	Исключение
		ВызватьИсключение;
	КонецПопытки;

	Если ВключенПривилегированныйРежим Тогда 
		ВключенПривилегированныйРежим = Ложь;
		УстановитьПривилегированныйРежим(ВключенПривилегированныйРежим);	
	КонецЕсли;
	
КонецПроцедуры

// Функция - Уточненный идентификатор задания
//
// Параметры:
//  Идентификатор - РегламентноеЗадание,
//					Строка - Идентификатор задания или задание
// 
// Возвращаемое значение:
//  УникальныйИдентификатор- Уникальный идентификатор задания
//
Функция УточненныйИдентификаторЗадания(Знач Идентификатор) Экспорт
	
	Если ТипЗнч(Идентификатор) = Тип("РегламентноеЗадание") Тогда
		Идентификатор = Идентификатор.УникальныйИдентификатор;
	КонецЕсли;
	
	Если ТипЗнч(Идентификатор) = Тип("Строка") Тогда
		ОбъектМетаданных = Метаданные.РегламентныеЗадания.Найти(Идентификатор);
		Если ОбъектМетаданных = Неопределено Тогда
			Идентификатор = Новый УникальныйИдентификатор(Идентификатор);
		Иначе
			Идентификатор = ОбъектМетаданных;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Идентификатор;
	
КонецФункции

// Для процедуры ИзменитьЗадание.
Процедура ОбновитьЗначениеСвойстваЗадания(Задание, ИмяСвойства, ПараметрыЗадания, ЕстьИзменения)
	
	Если Не ПараметрыЗадания.Свойство(ИмяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	Если Задание[ИмяСвойства] = ПараметрыЗадания[ИмяСвойства]
	 Или ТипЗнч(Задание[ИмяСвойства]) = Тип("РасписаниеРегламентногоЗадания")
	   И ТипЗнч(ПараметрыЗадания[ИмяСвойства]) = Тип("РасписаниеРегламентногоЗадания")
	   И Строка(Задание[ИмяСвойства]) = Строка(ПараметрыЗадания[ИмяСвойства]) Тогда
		
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Задание[ИмяСвойства]) = Тип("РасписаниеРегламентногоЗадания") 
		И ТипЗнч(ПараметрыЗадания[ИмяСвойства]) = Тип("Структура") Тогда
		ЗаполнитьЗначенияСвойств(Задание[ИмяСвойства], ПараметрыЗадания[ИмяСвойства]);
	Иначе
		Задание[ИмяСвойства] = ПараметрыЗадания[ИмяСвойства];
	КонецЕсли;
	
	ЕстьИзменения = Истина;
	
КонецПроцедуры


#КонецОбласти 


#Область СлужебныеПроцедурыИФункции  

// Удаляет дублирующиеся строки из табличной части.
//
// Параметры:
//  ТаблицаПроверки	 - ТабличнаяЧасть - Табличная часть в которой будет проверка.
//  ПолеПроверки	 - Строка		  - Наименование колонки.
//  УдалятьГруппы	 - Булево		  - Удалять группы в строках
//
Процедура УбратьДублиВТабличнойЧасти(Знач ТаблицаПроверки, Знач ПолеПроверки = "", Знач УдалятьГруппы = Истина) Экспорт 
	
	Если Не ПустаяСтрока(ПолеПроверки) Тогда
		
		ПроверкаСтрок = Новый Соответствие;
		МассивУдаляемыхСтрок = Новый Массив;
		Для Каждого строкаТЗ Из ТаблицаПроверки Цикл    
			
			Если Не ЗначениеЗаполнено(строкаТЗ[ПолеПроверки]) Тогда
				
				МассивУдаляемыхСтрок.Добавить(строкаТЗ);
				
			ИначеЕсли ПроверкаСтрок[строкаТЗ[ПолеПроверки]] = Неопределено Тогда 
				
				ПроверкаСтрок.Вставить(строкаТЗ[ПолеПроверки], строкаТЗ[ПолеПроверки]); 
				Если УдалятьГруппы Тогда 
					Если строкаТЗ[ПолеПроверки].ЭтоГруппа Тогда 
						МассивУдаляемыхСтрок.Добавить(строкаТЗ);	
					КонецЕсли;
				КонецЕсли;
				
			Иначе	
				МассивУдаляемыхСтрок.Добавить(строкаТЗ);
			КонецЕсли;
			
		КонецЦикла;	
		
		Если МассивУдаляемыхСтрок.Количество() > 0  Тогда 
			
			Для Каждого элМассива Из МассивУдаляемыхСтрок Цикл 
				ТаблицаПроверки.Удалить(элМассива);	
			КонецЦикла;	
			
		КонецЕсли;
	КонецЕсли;	
	
КонецПроцедуры  

// Добавить дней к дате
//
// Параметры:
//  Дата			 - Дата - Первоначальная дата
//  КоличествоДней	 - Число - Количество дней добавляемых к дате 
// 
// Возвращаемое значение:
//  Дата - дата с добавленными днями
//
Функция ДобавитьДнейКДате(Знач Дата, Знач КоличествоДней) Экспорт 

	Возврат Дата + КоличествоДней * 86400;
	
КонецФункции	

#КонецОбласти   

 
